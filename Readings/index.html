<!DOCTYPE html>

<html>

  <head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="screen.css" media="screen" type="text/css" />
    <title>Readings</title>
  </head>

  <body>
        <!-- Begin Website-->

	<!-- Navigation Bar -->
	    <div>
        <ul class="navigation" span style="list-style-type:none; margin: 0; padding: 0; width: 25%; background-color:#efefef; position: fixed; height: 100%; overflow: auto;">
            <li><a href="../index.html">Home</a></li>
            <li><a href="../Scratch Projects/index(2).html">Scratch Projects</a></li>
            <li><a href="../Textbook Q&A/index(3).html">Textbook Q&A</a></li>
            <li><a href="../Colleges/index(4).html">Colleges</a></li>
            <li><a href="../App Inventor/index(5).html">App Inventor</a></li>
            <li><a href="../Python Projects/index(6).html">Python Projects</a></li>
            <li><a href="../Midterm/index.html">Midterm</a></li>
            <li><a span style="color: white" class="active" href="#Readings">Readings</a></li>
            <li><a href="../Final/index.html">Final</a></li>
        </ul>
        </div>
    <!-- End Navigation Bar -->  
            
    <!-- Margining-->
        <div style="margin-left:25%;padding:1px 16px;height:1000px;">
    <!-- End Margining -->
           


    <!-- Header/Image Section -->
		<div id="header" class="section" style=border-color:#efefef;>
		    <img alt="" class="img-circle" src="https://proxy.duckduckgo.com/iu/?u=https%3A%2F%2Ftse4.mm.bing.net%2Fth%3Fid%3DOIP.2DPWK5lrndLb3_KvdB0wxgAAAA%26pid%3D15.1">
		    <p>Ashton Jacobs</p>
		</div>
	<!-- End Header/Image Section -->
        
	<!-- Reading Intro -->
		<div class="section">
		    <h1><span>What's All this Reading For?</span></h1>
		    <p class="intro">
            Over the course of our CS160 class, we've been assigned in our work schedule to take a look at
            random but helpful articles outside of our textbooks to read. As we read through these breif articles,
            we have to write a paragraph or so that summarizes what we want to take away from the readings. Below,
            I have provided individual sections for each of the readings that were assigned to us. Enjoy!
		    </p>
		</div> 
    <!-- End Reading Intro -->
    
    <!-- Big Ball of Mud -->
		<div class="section">
		    <h1><span>Code Reads #12: "Big Ball of Mud"</span></h1>
		    <p>In the text of "Big Ball of Mud," we see the author making a lot of analysis and conclusion as 
                to how a software team works together in many ways. How a software team interacts with each other
                is very critical to the production and outcome of a project or program. Even a small disagreement
                has the potential to easily set back the team. One of the main things the author points out to be
                a flaw in the teamwork is the arrogance shared by them towards other projects. A lot of teams
                build up their own egos too much that when they have to work onn a project that competes with
                others', it fails because of they're underestimation. They look at other people's projects as big
                balls of mud that aren't nearly as good as what the team <i>thinks</i> they're capable of competing
                with. It's this overconfidence and deprecation of others that leads them into error. The author
                states that "People build big balls of mud because they work. In many domains, they are the only 
                things that have been shown to work." What this means is that it's better to have a functioning 
                produt -even if it's not that stunning- than to have a glamorous product that doesn't actually
                work or do anything.
                <br/>A good note that the author brought up (And Rosenburg also brought this up in "Dreaming in Code")
                is that when you're taking on a software project, it's way better to start small and improve as 
                you go, than to shoot for too big of a project and get overwhelmed. And with this, if there's one 
                thing I'd like to take away from this article, it's that Big Balls of Mud are okay to have in a 
                project, and in most cases, it's better to have them than to suffer by too big of a project. 
            </p>
		</div>
    <!--End Big Ball of Mud-->
    
    <!--DevOps-->
        <div class="section">
            <h1><span>DevOps</span></h1>
            <p>In the text of IBM's summary on DevOps, we see them promoting a lot of the features their new
                software can fullfil. We are assigned to read the first 5 pages of this summary, and write this 
                paragraph on what we observed, read, as well as a piece of personal reflection by the end. 
                Throughout the reading, IBM continuously raises the point that all companies face a loss in clients
                because of a rising competitor utilizing a new software. In the buisness worl they were trying to 
                appeal to, cloud based software was taking the buisness market by storm, and they wanted DevOps to
                make it's claim on a part of this market. This was a very wise and true evaluation IBM made on the 
                buisness world and technology world in general. We're constantly seeing underdog companies overtake
                the corperations above them simply because they can coin a new feature into their buisness.
                <br/>IBM proceeds to make claims saying that DevOps will help buisnesses make their way in the 
                growing world and economy as it will give them the advantage of clous based software, and more useful
                skills that may supposedly even bring out needs in other coompetitions that the world of buisness
                feautres hasn't met yet. While this seems like a bold claim, IBM skillfully backs it up with facts
                and details about DevOps that make it more intriguing as a buisness feature, and this is when the
                promotion of DevOps helps/helped it take the market by storm as IBM intented.
                <br/>DevOps was said to be a buisness tool that would aid companies with countless things such as 
                fast cloud based opperation, security, automated tasks, stats and analysis, and more. All of this 
                would definitely be enough to sell DevOps already, seeing as how automation and cloud software alone
                was becoming such a huge deal in the buisness market. But they didn't stop there with the details and 
                emphasized that they didn't want DevOps to meet the competition as much as they wanted it to <i>be</i>
                and <i>create</i>competition. The final cherry on top is that IBM promised that they would continue to
                grow this software, so that even if a competition arises or sommething of the sort happens, DevOps
                would be able to stand up to all the cultural changes
                <br/>If there's one thing I want to take away from this, it's that IBM demonstrates a great job of taking 
                the software they have big or small, and promotes it in such a way that it's difficult to refuse. When you
                have a new product, talk about it as it is, and don't oversell it. If you think you have to oversell it, make 
                sure you did it openly enough that you can fulfil what you've promised.
            </p>
        </div>
    <!--End DevOps-->

    <!--Inevitable Pain-->
        <div class="section">
            <h1><span>Inevitable Pain</span></h1>
            <p>In the text of "Inevitable Pain," we see the author point out a lot of common error in prgramming,
                and offers us bits of advice to deal with this. From what I read and skimmed through, he asks us
                to first expect errors and bugs to appear in software all the time. You can never expect to program
                one thing perfectly, or to think you can accomplish one task perfectly on the first try. The world of
                coding and sofware development is full of ups and downs that you have to be editing and debugging all
                the time, so why not expect it to begin with.
                <br/>Another good thing he points out to us is that software requirements and cultral programming changes
                all the time. So while you can't expect your goals and programs to run perfectly the first time, you also
                can't necissarily expect the software to be relevant and perfect either since the community's ways of 
                writing code and running software change rapidly. 
                <br/> With all this in mind, the author asks that from this, we can learn to face the inevitable pain of 
                programming, and learn to adjust how we work according to how our mistakes turn out. What I want to take 
                away from this reading is that mistakes are bound to be made left and right in computer science, and that 
                it's how we learn from them that makes us 'good' workers or otherwise.
            </p>
        </div>
    <!--End Inevitable Pain-->

    <!--Software Is Hard-->
        <div class="section">
            <h1><span>Software Is Hard</span></h1>
            <p>In the text of "Software Is Hard," the author Kyle Willson summerizes some things and errors we see
                throuhghout "Dreaming In Code" that merits software as a hard concept. One of the things we see that
                makes software hard is when the teams take on such a big concept in there project for a benefit that 
                could've simply been added later. In the Dreaming book, they call this "Dogfood," in which the developers
                take on too big of a task for a small reward, when they should have just pushed the project out as it was, 
                and then added those benefits. The example Wilson gave was Cross-Platform development, which adds too much
                room for error, and the project sohoul've been released on one platform first, and others once they know 
                the software works.
                <br/>Another example given is how in Dreaming (Project Chandler), the team kept adding new members who would 
                typically suggest a new idea that would reset the whole project and make the scheduling ordeals more prominent 
                and unforgiving. On top of that, the people they hired were not qualified to write in the language they were 
                developing in. They should've gone away with the new additions that reset the progress, and stuck to their 
                idea of code and hire trained professionals to push the product out as fast as possible. 
                <br/> The idea being that in the end, there are so many reasons why software is hard. It's up to you and your 
                team to recognize bad patterns you're falling into or repeating. Wilson recommends we all become aware of all 
                the mistakes we make when working on software, make others aware of them, and avoid them entirely by commiting 
                to their prevention as a team.
            </p>
        </div>
    <!--End Software Is Hard-->
		
  </body>
</html>
